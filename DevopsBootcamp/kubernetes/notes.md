# Kubernetes

- deployment: stateless apps
- statefulSet: stateful apps or dbs

- __worker node:__
- container runtime:
  - also known as container engine
  - it is a software component that can run containers on a host operating system
  - It is responsible for managing the execution and lifecycle of containers within the Kubernetes environment.
- kubelet:
  - interacts with both the container and the node
  - starts the pod with the container inside
  - assigns resources from the node to the container like CPU, RAM, and storage resources
- kube-proxy:
  - forwards the requests
- __control Plane:__
- API server:
  - cluster gateway that gets any initial requests of any updatess into the cluster, or queries from the cluster
  - acts as a gatekeeper for authenitcation
- scheduler:
  - after the API server authenticates the request, it forwards it to the scheduler
  - scheduler decides which specific worker node would be able to handle the request of a new pod, component
  - it first looks at your request and sees how many resources the application needs and then matches it with a node that can handle it
  - it only decides on which node the new component should be scheduled, the actual scheduling is done by the kubelet
- controller manager:
  - detects state changes, like crashing pods, and tries to recover the cluster state as soon as possible.
  - it makes a request to the scheduler.
- etcd:
  - a key value store for the cluster state.
  - it is the cluster brain
  - cluster changes, like a crashing pod or a scheduled pod, get stored in the key-value store.
  - the other control plane processes consult it to compare the desired state of the cluster to the present state and therefore try to correct it to achieve the desired state which is stored in the etcd
  - it does not store application data

- kubectl: command line tool for k8s cluster
- install minikube:
  - <https://minikube.sigs.k8s.io/docs/start>
  - `homebrew install minikube`
  - `minikube start --driver docker`
  - `minikube status`

- __Basic kubectl commands:__
  - `kubectl get nodes`
  - `kubectl get pod` or `kubectl get po`
    - ContainerCreating: the pod is created but the pod inside is not yet started
  - `kubectl get services`
  - `kubectl create deployment NAME --image=image --[command] [args...] [options]`
    - `kubectl create deployment nginx-depl --image=nginx`
  - `kubectl get deploy` or `kubectl get deployment`
    - when you create a deployment, the deployment is the blueprint for creating pods
  - `kubectl get replicaset` or `kubectl get rs`
    - RS manages the replicas of a pod.
      - layers of abstraction:
      - deployment manages a replica set, which manages all the replicas of a pod
      - pods are an abstraction of the container
      - everything below a deployment is managed by k8s
  - `kubectl edit deployment nginx-depl` : it produces an autogenerated configuration file with default values that you can edit. As soon as you edit and save the changes in the file, the old pod will be killed and a new one started.
  - `kubectl logs [pod name]`
  - `kubectl describe pod [pod name]`
  - `kubectl exec -it [pod name] -- bin/bash`: enters the pod as a root user
  - `kubectl delete deployment [deploy-name] [deploy-name] ...`
  - `kubectl apply -f [file name]`
  - `kubectl delete -f [file name]`
  - each configuration file has 3 parts:
    - metadata
    - specification
    - status: autogenerated by k8s
  - `kubectl get deployment nginx-depl -o yaml > nginx-depl.yaml` : will direct the result into a file instead of stdout.
  - `kubectl get service` or `kubectl get svc`
  - `kubectl get pod -o wide`: get more information about the pod, including its IP
  - `kubectl get all` : get all components
    - `kubectl get all | grep mongodb`: filter the component you want

- __Secret Configuration file:__
  - kind: Secret
  - metadata/name: a name for your secret
  - type:"opaque"- default for arbitrary key-value pairs
  - data: the actual contents- in key-value pairs
- `echo -n 'username' | base64` will encode plain text 'username' with base64
- `echo -n 'dXNlcm5hbWU=' | base64 -d`: decode base64 text
- the secret has to be created before the deployment for it to be referenced in the deployment using `secretKeyRef`.

- __ConfigMap:__
  - configMap, just like secret has be created in the cluster before referencing it in a deployment
  - it is referenced as `configMapKeyRef` in the deployment file

- Types of Service in Kubernetes: <https://kubernetes.io/docs/concepts/services-networking/service/>
  - ClusterIP: or internal service. this is the default service if type of service is not specified.
    - exposes the service on a cluster-internal IP and makes the service only reacheable from within the cluster
  - LoadBalancer: will also give service an internal IP address.
    - But in addition, it will also give the service an external IP address where the external requests will be coming from
    - in minikube the extrnal IP is not automatically created.
      - `minikube service mongo-express-service` will assign the external service a public IP address
  - NodePort: port range: must be between ports 30000 and 32767
  - ExternalName:

- __Namespaces:__
  - `kubectl get namespace` or `kubectl get ns`

    ``` kubernetes default namespaces
    NAME              STATUS   AGE
    default           Active   2d21h
    kube-node-lease   Active   2d21h
    kube-public       Active   2d21h
    kube-system       Active   2d21h
    ```

  - kube-system:
    - Do not create or modify in this name space.
    - components deployed here are the system processes from the control plane or kubectl processes
  - kube-public:
    - contains publicly accessible data
    - it has a configmap that contains cluster information which is accessible even without authentication
    - `kubectl cluster-info`
  - kube-node-lease:
    - it holds information about the heartbeats of nodes.
    - so each node basically gets its own lease object that contains information about that node's availability
  - default:
    - You can create resources in this namespace(default, of no other namespace defined) or you can create your own namespace
    - `kubectl create namespace <my-namespace>`
    - you can also create the namespace using a configuration file:

    ```namespace confuration file:
    apiVersion: v1
    kind: Namespace
    metadata: my-namepsace
    ```

  - __Why namespaces:__
    - Structure your components: group resources into namespaces.
    - Avoid conflicts between teams, one application: Use namespaces to avaoid one team overwriting the other's application with configuration changes
    - Share services bewteen different environments. resource sharing: consider staging and development. namespaces give the ability to reuse components in both enviroments or in a blue-green deployment
    - access and resource limits on namespace level. Give teams access to their own namespaces and restrict their access to other namespaces where other teams are working. You can also limit the resources like CPU and RAM that one namespace can use
  - __characteristics of a namespace:__
  - You cannot access most resources from another namespace.
    - you would have to define configmaps and secrets for each namespace if they are sharing the same resource.
    - service can be shared across namespaces

    ```access service in another namespace:
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: mongodb-configmap
      namespace: my-namespace
    data:
      database_url: mongodb-service.database  #service.namespace
    ```

  - There are some components that can't be created within a namespace because they live globally on a cluster and cannot be isolated.
    - e.g. volume or persistent volume and node
    - `kubectl api-resources --namespaced=false`: to list all resources that cannot be namespaced
    - `kubectl api-resources --namespaced=true`
  - you can change the active namespace with kubectl:
    - `kubectl config set-context --current --namespace-my-namepsace`
  - you can also use kubens: more convenient, but needs to be installed separately.
  - `brew install kubectx`
  - How to use: <https://github.com/ahmetb/kubectx>

- __Services:__
  - each pod gets ots own IP address, but pods are ephemeral. Service has a stable IP address that is not linked to the pod lifecycle
  - it also provides load balancing to pods of the same application/replicas
  - they are a good absstraction of loose coupling for communication within and outside of the cluster
  - __ClusterIP:__
    - default service type if no other service is specified.

- __Ingress:__
  - List of Ingress Controllers you cna choose from: <https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/>
  -
